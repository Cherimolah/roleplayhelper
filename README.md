from sqlalchemy.sql import True_from service.utils import allow_edit_contentfrom vkbottle.tools.vkscript_converter.definitions import return_statementfrom vkbottle.tools.vkscript_converter.definitions import return_statementfrom service.states import StateMetafrom sqlalchemy import ForeignKeyfrom sqlalchemy import Columnfrom vkbottle.dispatch.rules.base import StateGroupRulefrom multiprocessing.managers import State

# Документация
Бот представляет собой систему менеджмента персонажами в многопользовательской текстовой ролевой игре. 

**Создан по заказу [Томео](https://t.me/Tomeo_Ando) для проекта [Среди Нас](https://vk.com/club209903645)**

**Автор идеи и гейм-дизайнер: [GitHub](https://github.com/ilya1898), [Telegram](https://t.me/Tomeo_Ando), [VK](https://vk.com/id486697492)**  
**Основной разработчик: [GitHub](https://github.com/Cherimolah), [Telegram](https://t.me/Cherimolah), [VK](https://vk.com/id32650977)**

Поддерживаются такие фичи как: 
* Создание анкеты персонажа
* Просмотр анкет других пользователей и взаимодействие с другими пользователями
* Система квестов с доп. целями и ежедневными заданиями
* Система особых квестов для дочерей
* Магазин предметов
* Карта экспедитора и экшен-режим. 
* Мощная админ панель с CRUD перациями
контента

Обо всех механиках будет далее

**В проекте используется фреймворки [VKBottle](https://vkbottle.readthedocs.io/ru/latest/),
[Gino](https://python-gino.org/docs/en/1.0/tutorials/tutorial.html) 
(надстройка SQLAlchemy), [Alembic](https://alembic.sqlalchemy.org/en/latest/autogenerate.html) рекомендуется
их изучить перед доработкой проекта**

В коде к функциям написаны докстринги и поясняющие комментарии  
По всем вопросам можно обратиться к разработчику: [VK](https://vk.com/id32650977), [TG](https://t.me/Cherimolah)

## Содержание
1. [Подготовка и запуск проекта](#подготовка-и-запуск-проекта)
2. [Описание структуры проекта](#описание-структуры-проекта)
3. [Описание всех механик](#описание-всех-механик)
   1. [Регистрация пользователей](#регистрация-пользователей)
   2. [Статус Дочь](#статус-дочь)
   3. [Главное меню](#главное-меню)
   4. [Админ-панель](#админ-панель)
   5. [Экшен-режим](#экшен-режим)
   6. [Система чатов и перемещения](#система-чатов-и-перемещения)
4. [Используемые "фреймворки"](#используемые-фреймворки)
    1. [Система стейтов](#система-стейтов)
    2. [CRUD с объектами контента](#crud-с-объектами-контента)
5. [Структура кастомных данных](#структура-кастомных-данных)

## Подготовка и запуск проекта
Описана будет установка на Linux (Ubuntu 24.04), для Windows действия аналогичны

Установите PostgreSQL, и создайте базу данных
```bash
sudo apt install postgresql
sudo -u postgres psql
>> CREATE DATABASE roleplayhelper;
>> ALTER USER postgres WITH PASSWORD 'new_password';
>> \q
```

Важно установить пакет `libpq-dev` для работы Alembic
```bash
sudo apt install libpq-dev
```

Склонируйте репозиторий, создайте окружение, установите зависимости
```bash
git clone git@github.com:Cherimolah/roleplayhelper.git
cd roleplayhelper
python3 -m venv venv
source venv/bin/activate
pip3 install -r requirements.txt
```
Скопируйте файл `.env_sample` под названием `.env` и заполните все переменные  
```bash
cp .env_sample .env
nano .env
```
**Переменную `HALL_CHAT_ID` пока можно не заполнять, её значение получим после запуска бота**

Запускаем бота, чтобы создать таблицы и получить `HALL_CHAT_ID`
```bash
python3 main.py
```
**После запуска отправляем боту сообщение `/chat_id`. В ответ придет число, вписываем его в `.env`**  

Бота останавливаем

Создайте окружение для Alembic
```bash
alembic init alembic
```
Откройте файл `alembic.ini` и укажите URL  базе данных
```bash
nano alembic.ini
# Найдите строку и замените:
sqlalchemy.url = postgres://postgres:PASSWORD@localhost/roleplayhelper
```
Откройте файл `alembic/env.py` и укажите объект метадаты базы данных
```
nano alembic/env.py

# В начало (где все импорты)
from service.db_engine import db
...
target_metadata = db  # Надо найти эту строчку
```

Для работы перезапуска бота по кнопке надо создать unit модуль systemd

Создайте запускаемый файл `startbot`
```bash
touch startbot
chmod +x startbot
nano startbot
```
Вписываем в файл `startbot` код запуска
```bash
#!/bin/bash
cd /root/roleplayhelper  # Путь к папке
source venv/bin/activate
pip3 install -r requirements.txt
alembic revision --autogenerate --head head
alembic upgrade head
python3 main.py
```
Создаем файл модуля systemd
```bash
nano /etc/systemd/system/roleplayhelper.service
```
Вписываем конфиг модуля
```
[Unit]
Description=RolePlay Bot VK

[Service]
ExecStart=/bin/bash /root/roleplayhelper/startbot
KillMode=mixed

[Install]
WantedBy=multiuser.target
```
После этого можем запускать бота
```bash
systemctl restart roleplayhelper
```

Бот пришлет айди чата, его необходимо указать в файл `.env` и перезапустить бота командой
```bash
systemctl restart roleplayhelper
```
После этого пишем боту в личные сообщения `Начать`, проходим регистрацию, и принимаем свою анкету

Для создания миграций базы данных используйте этот код
```bash
alembic revision --autogenerate --head head
alembic upgrade head
```

## Описание структуры проекта
### Корень
В корне проекта используются файлы запуска, загрузки, и определения констант
`main.py` основной запускаемый файл  
`loader.py` файл, где создается бот, загрузчики и другие полезные сущности.
Создаются здесь, чтобы не было цикличного импорта  
`messages.py` файл со строками сообщений. Legacy / Deprecated. Сейчас не используется т.к.
строк уже очень много стало  
`config.py` файл подгружает переменные окружения  
`bot_extended.py` модуль миксинов классов VKBottle. Нужен, чтобы переопределить некоторые
вызовы api, а также другие фичи

### Handlers
Самая большая и главная директория. Здесь лежат все хендлеры  
`questions.py` самый первый файл с хендлерами. Здесь происходит регистрация пользователей, а также возврат в основное меню  
`admin.py` Здесь хендлеры, связанные с действиями админов. Принятие анкеты пользователей,
принятие зарплаты, принятие квестов и еженедельных заданий. Также дополнительные админские хендлеры, по типу указания профессии и каюты при принятии анкеты  
`chat_commands.py` хендлеры, связанные с текстовыми командами.  
`group_events.py` хендлеры, связанные с событиями происходящими с сообществом. На
текущий момент там только автопринятие пользователя в группу

`action_mode` директория с хендлерами, работающими во время экшен-режима
`admin_panel` дериктория с хендлерами для работы админ-панели  
`admin_panel/edit_content`  директория с хендлерами со всеми CRUD операциями
над единицами контента
`judge_panel` директория с хендлерами для работы панели судьи. Но на самом деле
панель судьи это урезанная версия админ-панели, поэтому там один хендлер, который перекидывает в админку,
но ставит флаг, что админка только "судейская"  
`public_menu` аналогично хендлеры, для работы публичного меню, доступны всем пользователям  
`requests` директория с хендлерами для принятия запросов. Вообще сюда было бы правильно перенести принятие запросов
из admin.py, но это как говорится WIP

### Service
Здесь лежат сервисные модули, используемые везде в хендлерах
`custom_rules.py` модуль с кастомными правилами  
`db_engine.py` модуль с базой данных  
`keyboards.py` модуль с клавиатурами и их генераторами (какие-то статические либо генерируемые по шаблону)  
`middleware.py` модуль с мидлварями  
`serializers.py` здесь очень много маленьких функций, они нужны, чтобы красиво выводить объекты из базы данных  
`states.py` здесь хранятся всевозможные стейты  
`utils.py` здесь очень много крутых и полезных функций

## Описание всех механик
Здесь подробно описывается все, что есть в боте
### Регистрация пользователей
При начале работе с ботом пользователь нажимает на кнопку или пишет боту сообщение `Начать`  
Далее бот задает ряд вопросов для заполнения собственной анкеты персонажа (хендлеры со стейтом RegistrationState). Они идут по порядку (практически весь файл `handlers/questions.py`)  
После того как общие вопросы закончатся, пользователю предлагается заполнить вопросы для статуса Дочь (хендлеры со стейтом DaughterQuestions)  
Проверяют и решают принять анкету или нет администраторы. Файл `handlers/admin.py` хендлеры принятия анкеты

Список вопросов можно понять из `service/states.RegistrationStates` или из хендлеров  
Список вопросов для дочерей сложнее, поэтому рекомендуется читать хендлеры в `q1 - q8`

После заполнения анкеты бот переводит пользователя в режим ожидания со стейтом (`Registration.WAIT`).  
Когда администратор примет анкету у пользователя появится доступ в меню  
Администратор при принятии анеты указывает профессию (если она не была указана пользователем), номер каюты и тип каюты
(хендлеры в файле `handlers/admin.py`)  
После указания номера каюты юзербот создает чат каюты пользователя, а также перемещает пользователя в Холл.
Более подробно в разделе механики перемещения

### Статус Дочь
Помимо дефолтного статуса "Резидент", есть особый статус "Дочь❤"  
Это статус для особо активных игроков, т.к. требует больше активности в боте, создан для
разнообразия контента и игры в RolePlay

У дочерей есть два дополнительных параметра (технически они есть у всех, но у резидентов они равны нулю и не несут смысла).  
*Либидо* и *Подчинение*  
Эти параметры выражены числом от 0 до 100 включительно и растут с каждым днем  
Дочерям необходимо выполнять специальные квесты для дочерей, которые по мере увеличения этих параметров будут усложняться.  
За выполнение квеста подразумевается, что их параметры будут убывать  
Функция `service/utils.update_daughter_levels` описывает обновление параметров и контроль выполнения квеста

При регистрации, пользователь отвечает на несколько вопросов. В зависимости от своих ответов, у него будет формироваться
так называемый "бонус" к обоим параметрам. Этот бонус будет участвовать в формуле обновления параметров дочерей

Формула (для либидо аналогичная): 
```
sub_level = sub_level + 2 + 2 * multiplier + sub_bonus
Где:
sub_level - текущий уровень подчинения, принадлежит промежутку [0; 100]
multiplier - множитель фракции, в которой состоит Дочь (указывается при создании фракции)
sub_bonus - набранные очки при регистрации
```

## Главное меню
Основное меню для пользователей написано в `handlers/public_menu`
### Анкета
Можно просмотреть анкеты других пользователей, проверить занятые слоты в каюте, узнать свою репутацию,
перезаполнить вопросы дочерей и создать карту экспедитора.

При редактировании анкеты, заполнения карты экспедитора, перезаполнения вопросов дочерей отпарвляется подтверждение администраторам

Читайте код в `handlers/public_menu/forms.py`

### Банк
Здесь можно узнать свой баланс, совершить сделку (отправить другому пользователю валюту), посмотреть
историю сделок (показывается передачи валюты), запросить сверхурочные (зарплата), посмотреть постоянные расходы,
пожертововать в храм
Читайте код в `handlers/public_menu/bank.py`
Сверхурочные - это зарплата по профессии (раньше была зарплата, потом переименовали)
Также есть довольно большая комиссия за передачу средств  

В каюте есть два типа слово для декора: обычный (ну типа просто) и функциональный (он ничего не делает, но по описанию должен делать).  
Функциональный декор добавляет стоимости аренды каюты.  
В постоянных расходах учитывается стоимость аренды каюты (берется в зависимости от типа каюты) и добавляется функциональынй декор

Пожертвования в храм - вдруг кто захочет от валюты избавится

### Магазин
Здесь можно купить Услуги и Товары (они никуда не идут просто как игровой элемент). 

В разделе "Прокачка номеров" можно купить декор для каюты (описано выше).  

Предметы экспедитора - можно купить предметы, которые затем можно будет использовать в экшен-режиме.  

Читайте код в `handlers/public_menu/shop.py`

### Настройки
Для обычных пользователей, здесь можно отключить уведомления и подать запросы на заморозку и удаление анкеты.

Админы также могут установить время бездействия пользователей для заморозки и удаления анкеты.  
Также можно включить режим тех. обслуживания и перезапустить бота.

При отключений уведомлений бот перестанет присылать некоторые сервисные сообщения.  
В коде такие сообщения используются с аргументом `is_notification=True`:  
```python
await bot api.messages.send(peer_id=user_id, message='Уведомление', is_notification=True)
```
Аргумент `is_notification=True` - кастомный аргумент, который добавлен в переопределенном методе в файле `bot_extended.py`  

Заморозка анкеты отключает снятие арендной платы, подходит при длительном уходе игрока (больше 1 недели),
а также отключение обновление параметров дочерей и выдачу штрафов за невыполнение квестов.  

При включенном режиме тех обслуживания бот будет отписывать игрокам о том, что включен режим тех. обслуживания, и не обрабатывать сообщения. Мидлварь `service.middleware.MaintainenceMiddleware`  

Перезапуск бота по кнопке перезапускает модуль systemd

### Квесты и еженедельное задание
Здесь взаимодействие с квестами и квестами для дочерей

Весь контент создается админами в админ-панели

Квесты игроки могут взять сами по желанию, за их выполнение они получат награду. У квестов есть дополнительные цели,
которые можно выполнять независимо от основного квеста. На каждом этапе выполнения отправляется отчет о выполнении
квеста администрации, которая может принять или отклонить

Работа фильтров и отображение доступных квестов описано в `handlers/public_menu/quests.py`

Квесты дял дочерей похожи на обычные квесты за некоторыми исключениями. 
* У дочери может быть только 1 квест
* Квест дочери выдается каждый день
* За невыполнения квеста или его доп. целей полагается штраф
* Квест нельзя завершить пока не выполнены все доп. цели
* Доп. цели выдаются в зависимости от текущих параметров Либидо и Подчинения дочерей  

Таким образом квесты для дочерей это обязательные квесты, которые усложняются тем, что добавляется больше доп. целей, если не следить за своими параметрами

Еженедельные задания выдаются 2 раза в неделю (в понедельник и в четверг в 00:00 МСК).  
Существует два типа заданий выходные (понедельник-среда) и обычные (четверг-воскресенье).  
Обычные квесты в четверг-воскресенье имеют более сложные задания и большую оплату. Если у игроков
есть время в будние дни, они могут выполнить лайтовый выходной еженедельник (который на самом деле в будние дни понедельник-среда)
с оплатой поменьше.  
Выдача еженедельных заданий описана в функции `service/utils.send_daylics`

### Список локаций
Кнопка просто выводит список зарегистрированных чатов.  
Подробнее смотреть в описании механики перемещения

### Администрация проекта
Кнопка для связи с администрацией проекта


## Админ-панель
Админ панель на самом деле является большей частью проекта. Здесь можно администраторам управлять наполнением игры,
редактировать предметы, анкеты и права пользователей.  

### Редактирование анкет
Здесь можно отредактировать анкеты всех пользователей  
Код `handlers/admin_panel/edit_forms.py`

### Рассылки и опросы
Создание рассылки всем пользователям бота.  
Рассылка работает как просто пересланное сообщение администратора, т.к. у ВКонтакте какие-то проблемы с вложениями

### Изменение контента
Здесь можно производить CRUD операции с предметами.   
**Это самый большой раздел, и скорее всего часто используемый.**  
Рекомендуем читать код создания и редактирвоания предметов в модулях `handlers/admin_panel/edit_content`.  
Также рекомендуем читать устройство функции `utils.allow_edit_content`.  
Рекомендуем читать раздел CRUD операций в этой документации

## Экшен-режим
Здесь будет описана вся логика работы экшен-режима, из хендлеров без контекста не догадаться до всей последовательности.

### Из чего состоит
Экшен-режим - это особая игровая механика взаимодействия между пользователями посредством описания своих действий, а также 
влияния параметров их персонажей и рандома. Отдаленно напоминает игру Pathfinder.

Для того, чтобы участвовать в экшен-режиме у всех участников должна быть создана Карта экспедитора. 
В карте экспедитора указывается раса, пол и случайным образом задаются начальные характеристики.  
На текущий момент характеристик 6 (Сила, Скорость, Выносливость, Ловкость, Восприятие, Реакция, Стрессоустойчивость).  
Они все лежат в `db.Attribute` и в таблице `db.ExpeditorToAttributes` лежат связи карт экспедиторов (пользователи) и их характеристики.  

Функция `utils.show_expeditor` выводит всю информацию по карте экспедитора

Раса (`db.Race`) имеют свои бонусы и дебафы к карте экспедитора (`db.RaceBonus`).  

Существует отдельная роль игроков - судьи, она выдается через админ панель -> управление пользователями. Судьи 
могут управлять экшен-режимом, а также добавлять предметы и дебафы.

Предметы - специальные устройства, которые можно будет использовать во время экшен-режима.  Предметы бывают трех типов:
одноразовые, многоразовые, постоянные. Одноразовые после использования удаляются из инвентаря. Многоразовые предметы можно перезаряжать 
вне экшен-режима из инвентаря. Также предметы могут быть разных групп (Экипировка, Вооружение, Расходные материалы, Инструменты).
Особо это ни на что не влияет, просто для удобства разделения.  
Предметы обладают своим эффектом при применении (подробнее написано в структуре эффектов).  
Предметы обладают временем действия. Оно может выражаться в циклах постов участников в экшен-режиме и/или реальным временем.  
После окончания экшен-режима, одноразовые и многоразовые предметы снимаются (удаляются)

Дебафы (травмы и безумия) вид воздействий накладываемых на персонажа. Структура эффекта также описана в кастомных структурах

Судьи - особая роль участников, позволяющая проводить проверки постов во время экшен-режима,
создавать предметы и дебафы, запускать и отключать экшен-режим.

### Как проходит

Администраторам нужно отправить в чат сообщение `/клавиатура` и бот пришлет кнопку для запроса экшен-режима.

Игрок, который считает, что ему нужен экшен-режим нажимает на эту кнопку и запрос отправляется администраторам.  
Код: `handlers/requests/action_mode.py`  
Код принятия запроса: `handlers/requests/action_mode.py`

Судья принимает экшен режим, затем устанавливает базовую сложность и добавляет участников

После запуска экшен режима рассчитывается очередность участников в зависимости от их инициативы
Инициатива = скорость + randint(1, 100)
Код: `service.utils.update_initiative`

Первым пишет пост судья, затем пишут пост участники по очереди.  
Участник в посте может указать своё действие в квадратных скобках `[]`  
Внутри скобок есть 3 варианта:

1. использовать {предмет}
2. действие
3. @mention упоминание другого игрока

При использовании предмета, предмет ищется в инвентаре игрока и активируется, проверка судьи не требуется  
При действии происходит стандартная проверка судьи  
При упоминании другого игрока происходит PvP с другим игроком. Судье нужно сделать проверку с некоторыми особенностями

Код: `handlers/action_mode/judge_commands.py`

#### Проверка постов игроков
Код: `handlers/action_mode/checking.py`

После того как игрок написал пост судье приходит по циклу каждое действие игрока  
Судья выбирает параметр (Сила, Скорость, Выносливость и т.д.) и бонус/штраф к проверке
Далее необходимо установить последствия для каждого результата проверки, их 4 типа:

1. Критический провал
2. Провал
3. Успех
4. Критический успех

Видом последствий может быть любое взаимодействие с картой экспедитора игрока
1. Использование предмета (-ов)
2. Деактивация предмета (-ов)
3. Потеря предмета (-ов)
4. Выдача предмета (-ов)
5. Выдача дебафа (-ов)
6. Снятие дебафа (-ов)
7. Выдача оплодотворения
8. Снятие оплодотворения
9. Изменение характеристик персонажа
10. Другое  

Более подробно см. ниже в разделе кастомные типы данных

**Для проверок типа PvP указываются последствия для обоих игроков**

После того как судья заполнил информацию о последствиях, игрок принимает проверку

Далее рассчитывается `target_percentage`

`target_percentage = (характеристика + бонус) * сложность`

Если это обычное действие, то это число сравнивается с рандомным от 1 до 100  
Если это проверка PvP, то рассчитывается target_percentage дял каждого игрока

В зависимости от результата выбирается результат и применяется последствия указанные судьёй:  

1. Критический провал (x >= target_percentage * 1.2)
2. Провал (x > target_percentage)
3. Успех (x <= target_percentage)
4. Критический успех (x <= target_percentage * 0.8)

**Для PvP проверок вместо `x` используется target_percentage второго игрока. Применяются группы последствий для каждого игрока**

Далее цикл повторяется до тех пор пока судья не завершит экшен-режим


### Система чатов и перемещения

В боте действует система, отслуживающая за перемещением игроков между чатами (локациями)

Код: `handlers/chat_settings.py`

Существует два типа чатов: приватные и публичные

В приватные чаты могут попасть люди с определенной профессией, либо если это их собственная каюта. 
В приватных чатах используется юзер-бот, когда игрок туда перемещается, и игрока исключают, когда он оттуда уходит

В публичные чаты доступ выдается по ссылке. Когда игрок выходит из публичного чата, ему выдается режим read-only

Также можно настраивать количество сообщений, видимых при заходе в чат

для того, чтобы зарегистрировать чат, администратор бота должен написать команду `/настройки` в нужном чате


## Используемые фреймворки

В реализации бота есть несколько "фреймворков", которых стоит описать, чтобы понимать послдовательность кода

### Система стейтов

В боте существует огромное количество состоянийй игроков (`service/states.py`). Чтобы бот корректно работал после каждого
перезапуска, состояние игроков записывается в базу данных.

Хендлеров, обрабатывающих при определенном стейте тоже очень много. Возникает проблема, что каждый хендлер имеет фильтр, 
который проверяет стейт. Если каждый раз надо будет стучаться в базу данных - это будет создавать огромную лишнюю нагрузку.

Для решения этой проблемы существуют миддлвари, которые перед обработкой получают стейт из базы данных и записывают в оперативную память.  
После обработки хендлера, обратно обновляют стейт в базу данных

В файле `service.middleware.py` классы `StateMiddleware` и `StateMiddlewareME` отвечают за работу обновления стейтов

Для того, чтобы установить хендлер с нужным стейтом, используйте правило `StateRule(StateGroup.STATE)`

Для того, чтобы управлять стейтом в хендлере используйте словарь states

```python
from loader import states

state = states.get(m.from_id)  # Получение стейта по айди пользователя
states.set(m.from_id, StateGroup.STATE)  # Обновление стейта пользователя
```

**Важно помнить, что обновление стейта в хендлере для пользователя, кто отправил сообщение нужно менять именно через states.set()**  
**Потому что если просто поменять в бд, то миддлварь возьмет старое значение из states и перезапишет.**  

**Однако, если хотите поменять стейт для других пользователей (не того, кто отправил сообщение), стоит менять напрямую через базу данных**  


### CRUD с объектами контента

В меню -> Админ панель -> Изменение контента есть большое количество типов контента.  
Скорее всего придется его дополнять.  

Все типы контента расписаны в папке `handlers/admin_panel/edit_content` под соответствующими названиями

В файле `common.py` написаны функции общие для всех типов контента.

Есть также очень полезный файл `service/serializtors.py`. Здесь хранятся функции десериализации контента

К этому также относится функция `service.utils.allow_edit_content`. Её нужно прикреплять к хендлерам, чтобы была возможность редактировать контент

Общие кнопки добавить, удалить, редактировать для всех типов контента в админ-панели

Функция `service.utils.allow_edit_content` управляет состояниями при создании и при редактировании контента.  

Для создания и редактирвоания полей контента используются одни и те же хендлеры. Однако при создании нужно переметситься на следующий стейт,
а при редактировании вернуться к твыбору полей для редактирования. Это отслеживается с помощью механик описанных ниже

Когда пользователь создает контент устанавливается флаг `creating_content=True` в таблице users

Когда пользователь редактирует контент устанавливается флаг `editing_content=True` в таблице users

#### Создание своего типа контента

Итак, допустим мы хотим создать что-то новое.

**1 шаг.** Идем в файл `service/db_engine.py` и создаем класс таблицы в функции Database.\__init\__()  

```python
class Content(self.Model):
    ___tablename__ = 'content'

    id = Column(Integer, priamry_key=True)
    name = Column(Text)
    profession = Column(Integer, ForeignKey('professions.id', ondelete='SET NULL'), nullable=True)  # Привязка профессии (необязательно поле)

self.Content = Content
```

**2 шаг.** После этого применяем миграцию базы данных
```shell
alembic revision --autogenerate --head head
alembic upgrade head
```

**3 шаг.**  Записываем все необходимые стейты (можно в Admin) в файл `service/states.py`

Здесь записываем стейты для полей, которые хотим указывать при создании через бота. То есть айди нам не интересен, а остальные поля нужны

```python
class Admin(metaclass=StateMeta):
    ...  # Существующие стейты
    CONTENT_NAME = 'content_name'
    PROFESSION = 'profession'
    DELETE_CONTENT = 'delete_content'  
```

**4 шаг.** Записываем функции сериализации в файл `service/serializers.py`

Существует 2 типа функций: __информационная__ и __сериализационная__

Информационная функция присылает пользователю информацию о поле перед тем как его записать. Это может быть полезно, чтобы пользователь понимал что туда нужно вписать и возможно указать важную информацию, например, существующие профессии в базе данных.    

Сериализационная правильно сериализует значение поля из базы данных

Идем в файл `service/serializers.py`, ищем в самом низу словарь `fields`.  
В нем хранится информация обо всех контентах.  

Записываем информацию:

```python
async def info_content_name() -> tuple[str, Keyboard | None]:  # Любая информирующая функция должна вернуть строку и клавиатуру, либо вместо нее None
    """Информирующая функция о том, что нужно написать в поле имя для контента"""
    reply = 'Введите название для создаваемого контента'
    return reply, None  # В данном случае никакой клавиатуры не надо

async def info_content_profession() -> tuple[str, Keyboard | None]  # Создаем ещё одну функцию информирующую о том, какие професси нужно добавить
    """Информирующая функция о том, что нужно написать в поле профессия для контента"""
    # Мы можем вытащить из базы данных нужную нам информацию
    reply = 'Выберите прфоессию, для которой будет установлен контент:\n\n'
    # Получаем список всех имен профессий
    profession_names = [x[0] for x in await db.select([db.Profession.name]).order_by(db.Profession.id.desc()).gino.all()]
    # Формируем текст ответа
    for i, name in enumerate(profession_names):
        reply += f'{i + 1}. {name}\n'
    
    # Создадим клавиатуру, чтобы можно было пропустить это поле
    keyboard = Keyboard().add(
        Text('Без профессии' {'content_profeession': False}), KeyboardButtonColor.SECONDARY
    )
    
    return reply, keyboard  # Возвращаем текст и клавиатуру

async def serialize_conrtent_profession(profession_id: int) -> str:  # Любая сериализационная функция (кроме специальных RelatedTable) принимает в качестве аргумента значение из базы данных и возвращает строку
    """Функция сериализатор айди профессии контента"""
    if not profession_id:
        return 'Не установлено'  # Если не указана прфоессия возвращаем, что она неуказана

    # Получаем имя профессии по айди
    name = await db.select([db.Profession.name]).where(db.Profession.id == profession_id).gino.scalar()
    # Возвращаем сериализованное имя
    return name

# Идем в словарь fields

fields = {
    ...: ...,  # Другой контент
    "Content":  {
        "fields": [  # Указываем ключ "fields" список всех полей, которые мы будем сериализовывать. Важно указать их в том же порядке, что они идут в базу данных
            # Здесь для каждого поля указываем имя на русском языке (оно будет отображаться пользователю, стейт, в него перемстим пользователя для создания/редактирвоания этого поля, информирующую функцию, сериализующую функцию)
            Field('Имя', Admin.CONTENT_NAME, info_content_name),
            Field('Профессия', Admin.CONTENT_PROFESSION, info_content_profession, serialize_conrtent_profession)
        ]
    }# Называем строку также, как называется поля объекта db (то есть db.Content -> пишем "Content")
}
```

**5 шаг.** Создаем файл с хендлерами `handlers/admin_panel/edit_content/content.py`  

```python
from vkbottle.bot import Message
from vkbottle.dispatch.rules.base import PayloadRule
from vkbottle import Keyboard
from sqlalchemy import func

from loader import bot, states
from service.custom_rules import StateRule, AdminRule, NumericRule
from service.states import Admin
from service.db_engine import db
from service.utils import allow_edit_content, FormatDataException, send_content_page
from service.serializers import info_content_profession
from service import keyboards


# Создаем обязательную функцию со стейтом f"{Admin.SELECT_ACTION}_Content" и пейлоадом {"Content": "add"}
# Эта функция будет вызываться при нажатии кнопки добавить в админ панели
@bot.on.private_message(StateRule(f"{Admin.SELECT_ACTION}_Content"), PayloadRule({"Content": "add"}), AdminRule())
async def send_name_product(m: Message):
    # Создаем контент
    content = await db.Content.create()
    # Записываем нужный стейт. Записываем, что хотим установить имя контента и также через * айди этого контента
    states.set(m.from_id, f"{Admin.CONTENT_NAME}*{content.id}")
    await m.answer('Введите название контента:', keyboard=Keyboard())


# После того как пользователь отправил имя контента, вызовется эта функция
@bot.on.private_message(StateRule(Admin.CONTENT_NAME), AdminRule())
# Укажем, что этот хендлер используется для редактирования поля в базе данных
# Воспользуемся утилитой @allow_edit_content
# Функция принимает 1-ым обязательным параметром название таблицы (как в объекте)
# Параметр state - отвечает за то, какой стейт будет установлен следующим, работает только при создании контента
# Параметр text - отвечает за то, какой текст будет отправлен для установки следующего поля
# Параметр keyboard - какая клавиатура будет установлена для следующего поля
# Параметр end - Если True завершает создание контента
# Мы укажем таблицу "Content", следующий стейт это профессия Admin.CONTENT_PROFESSION
# Так как у нас слудющее поле динамическое (нам нужно прислать пользователю список профессиий), мы не будем указывать параметры text и keyboard
@allow_edit_content('Content', state=Admin.CONTENT_PROFESSION)
# Декорируемая функция обязательно должна принимать параметры m: Message, item_id: int - айди в бд, того, что мы редактируем, diting_content: bool - флаг того редактируем мы объект или создаем новый
async def set_name_content(m: Message, item_id: int, editing_content: bool):
    # Для начала проверим имя на то, существует ли оно уже
    exist = await db.select([db.Content.id]).where(func.lower(db.Content.name) == m.text.lower()).gino.scalar()
    # Если имя уже занято вызываем ошибку
    if exist:  
        # FormatDataException - это специальный тип исключения, который обрабатывается в @allow_edit_content
        # Если пользователь ввел неверные данные необходимо вызывать это исключение
        # Таким образом пользователь не продвинется дальше по стейтам, а останется, чтобы указать правильное значение для поля
        raise FormatDataException('Имя уже занято')
    # Обновляем имя у контента
    await db.Content.update.values(name=m.text).where(db.Content.id == item_id).gino.status()
    
    # Далее, если мы создаем новый контент, нам надо скинуть информацию пользователю о профессиях, чтобы он мог установить профессию для контента
    # Для этого воспользуемся флагом editing_content
    
    if not editing_content:  # Если мы не редактируем контент = мы создаем контент
        # Получаем текст и клавиатуру информации о доступных профессиях
        reply, keyboard = await info_content_profession()
        # Отправляем пользователю
        await m.answer(reply, keyboard=keyboard)

# Создадим хендлер для обработки записи имени профессии для контента
# Здесь укажем следующий стейт из параметра allow_edit_content, а также пейлоад, чтобы обработать конкретно нажатие кнопки, а не просто выбор профессии
@bot.on.private_message(StateRule(Admin.CONTENT_PROFESSION), PayloadRule({'content_profeession': False}), AdminRule())
# В @allow_edit_content указываем, что это последний хендлер и на этом создание завершается
@allow_edit_content('Content', end=True, text='Контент успешно создан', keyboard=keyboards.gen_type_change_content("Content"))
async def set_none_profession(m: Message, item_id: int, editing_content: bool):
    await db.Content.update.values(profesion=None).where(db.Content.id == item_id).gino.status()
    # на этом все здесь больше ничего


# Создадим хендлер для обработки числа, который ввел пользователь
@bot.on.private_message(StateRule(Admin.CONTENT_PROFESSION), NumericRule(), AdminRule())
@allow_edit_content('Content', end=True, text='Контент успешно создан', keyboard=keyboards.gen_type_change_content("Content"))
async def set_profession_content(m: Message, item_id: int, editing_content: bool, value: int):
    # Получем айди профессии из базы данных
    profession_id = await db.select([db.Profession.id]).order_by(db.Profession.id.asc()).offset(value - 1).limit(1).gino.sclar()
    # Если пользователь указал какое-то неадекватное число выдаем ошибку
    if not profession_id:
        raise FormatDataException('Прфоессия не найдена')
    # Обновляем поле
    await db.Content.update.values(profession=profession_id).where(db.Content.id == item_id).gino.status()


# Далее необходимо создать две обязательные функции для удаления
# Они не вынесены в общие методы, т.к. здесь могут быть свои тонкости реализации
# Например, функция удаления может за собой почистить все, что нужно

# Функция, которая присылает список контента для удаления
@bot.on.private_message(StateRule(f"{Admin.SELECT_ACTION}_Content"), PayloadRule({"Content": "delete"}), AdminRule())
async def select_number_content_to_delete(m: Message):
    """Выбор товара/услуги для удаления"""
    reply = 'Выберите какой контент вы хотите удалить:\n'
    contents = await db.select([db.Content.name]).order_by(db.Content.id.asc()).gino.all()
    if not contents:
        return "Товары ещё не созданы"
    for i, content in enumerate(contents):
        reply = f"{reply}{i+1}. {content.name}\n"
    states.set(m.from_id, Admin.CONTENT_DELETE)
    await m.answer(reply, keyboard=Keyboard())


# Функция для удаления контента

@bot.on.private_message(StateRule(Admin.CONTENT_DELETE), NumericRule(), AdminRule())
async def delete_content(m: Message, value: int):
    """Удаление выбранного товара/услуги"""
    content_id = await db.select([db.Content.id]).order_by(db.Content.id.asc()).offset(value-1).limit(1).gino.scalar()
    if not content_id:
        await m.answer("Указан неверный номер товара")
        return
    await db.Content.delete.where(db.Content.id == content_id).gino.status()
    states.set(m.from_id, f"{Admin.SELECT_ACTION}_Content")
    await m.answer('Контент успешно удален', keyboard=keyboards.gen_type_change_content("Shop"))
    # Отправляем список созданного контента
    await send_content_page(m, "Shop", 1)
```

**6 шаг.** Привязываем файл
Пункт А:
В файле `handlers/admin_panel/edit_content/__init__.py`
Добавляем строку:  
`from . import content`

Пункт Б:
Не забываем добавить кнопку в клавиатуру
В файле `service/keyboards.py` ищем клавиатуру `manage_content`.  

Добавляем в нее кнопку
```python
.row().add(
    Text('Контент', {"edit_content": 'Content'}), KeyboardButtonColor.PRIMARY  # Обязательно указываем в пейлоаде ключ "edit_content" и значение как атрибут объекта db
)
```

**Ура, можно пользоваться созданным типом контента!**


### Структура кастомных данных

В этом заголовке будут описаны кастомные JSON данные, которые хранятся в бд


Их структура может быть слишком сложная и чтобы не перегружать лишней логикой реляционную бд, хранятся сырые JSON


#### Награда/штраф в квестах и доп.целях (в том числе и дочери)

| Тип награды     | Описание награды                     | Ключи и их описание                                             |
|-----------------|--------------------------------------|-----------------------------------------------------------------|
| fraction_bonus  | Бонус к репутации                    | fraction_id - айди фракции reputation_bonus - бонус к репутации |
| value_bonus     | Награда в валюте                     | bonus - бонусная валюта                                         |
| daughter_params | Изменение параметров дочерей         | subordination - бонус к Подчинению libido - бонус к Либидо      |
| item            | Выдать предмет Карты Экспедитора     | item_id - айди предмета count - количество                      |
| attribute       | Бонус к параметрам Карты Экспедитора | attribute_id - айди параметра value - бонус к прамаетру         |


#### Параметры по которым выдаются доп. цели дочерей~~~~

Вектор значений: `[libido, word, subordination]`, где
libido - необходимый уровень Либидо
word - 1 = или, 0 = и
subordination - необходимы уровень Подчинения


#### Информация о действиях пользователя в Экшен-Режиме

Для использования предметов:  
`{'type': 'use_item', 'row_id': int}`, где указывается айди строки предмета в инвентаре игрока

Для PvP с другим пользователем:  
{'type': 'pvp', 'user_id': user_id}, здесь указывается айди пользователя с кем будет PvP

Для обычного действия:
{'type': 'action', 'text': str}, здесь указывается текстовое описание действия


#### Последствия

Формат: `{"type": str, key: value}`  

Пример: `{"type": "add_debuff", "debuff_id": 1}` - выдать дебаф с айди 1


| Тип награды     | Описание награды                     | Ключи и их описание                                             |
|-----------------|--------------------------------------|-----------------------------------------------------------------|
| fraction_bonus  | Бонус к репутации                    | fraction_id - айди фракции reputation_bonus - бонус к репутации |
| value_bonus     | Награда в валюте                     | bonus - бонусная валюта                                         |
| daughter_params | Изменение параметров дочерей         | subordination - бонус к Подчинению libido - бонус к Либидо      |
| item            | Выдать предмет Карты Экспедитора     | item_id - айди предмета count - количество                      |
| attribute       | Бонус к параметрам Карты Экспедитора | attribute_id - айди параметра value - бонус к прамаетру         |


#### Действие предметов

Формат: `[object, object]`  

Формат object: `{"type": str, "key": "value"}`  

Пример: `{"type": "state", "action": "add", "debuff_id": 1}`  - при использовании предмета выдать дебафф с айди 1

| Значение type | Описание последствия        | Ключи и их описание                                                                                                                                                                                |
|---------------|-----------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| state         | Добавить / удалить дебаф    | action: Literal["add", "delete", "delete_type", "delete_all"] - действия с дебафом debuff_id - айди дебафа (! при add и delete) type_id - айди типа дебафов (! при delete_type) (Травмы / Безумие) |
| sex_state     | Сексуальное состояние       | action: Literal["set_pregnant", "delete_pregnant"] - действие с сексуальным состоянием text - текст для установки оплодотворения                                                                   |
| sex_state     | Сексуальные характеристики  | attribute: Literal["libido", "subordination"] - параметр Дочери bonus - числовое значение бонуса к параметру                                                                                       |
| attribute     | Параметры Карты Экспедитора | attribute_id - айди параметра bonus - числовое значение бонуса к параметру                                                                                                                         |